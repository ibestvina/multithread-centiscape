package org.cytoscape.pesca.internal;


/*
 * PescaStartMenu.java
 *
 * Created on 13 novembre 2007, 13.37
 */
/**
 *
 * @author  scardoni
 */

//import cytoscape.CyNetwork;
//import cytoscape.view.CyNetworkView;
import java.awt.Component;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import javax.swing.*;

import org.cytoscape.application.CyApplicationManager;
import org.cytoscape.application.swing.CySwingApplication;
import org.cytoscape.application.swing.CytoPanel;
import org.cytoscape.application.swing.CytoPanelComponent;
import org.cytoscape.application.swing.CytoPanelName;
import org.cytoscape.model.CyNetwork;
import org.cytoscape.model.CyNode;
import org.cytoscape.model.CyTableUtil;
import org.cytoscape.model.events.RowsSetListener;
import org.cytoscape.task.read.LoadNetworkURLTaskFactory;
import org.cytoscape.task.read.OpenSessionTaskFactory;
import org.cytoscape.view.model.CyNetworkView;
import org.cytoscape.work.AbstractTask;
import org.cytoscape.work.Task;
import org.cytoscape.work.TaskIterator;
//import utils.Centrality;
import org.cytoscape.work.TaskManager;
import org.cytoscape.work.TaskMonitor;

public class PescaStartMenu extends JPanel implements CytoPanelComponent {
    
    
    public CyNetworkView currentnetworkview;
    public CyNetwork currentnetwork;
    private int numberofcentralities = 5;
    private boolean calculating = false;
    private PescaAlgorithm Pescaalg; 
    private PescaCore pescacore;
    private PescaThreadEngine ThrEng;// = new PescaThreadEngine(Pescaalg);
    private boolean[] CheckedCentralities = new boolean[numberofcentralities];
    private boolean directed = false;
    private boolean weighted=false;
    private boolean[] LoadedCentralities = new boolean[numberofcentralities];
    private CytoPanel cytopanelwest;
    private CytoPanel cytopaneleast;
    private double inizio;
    private double fine;
    private CyNetwork lastworkednetwork;
    private CyNetworkView lastworkedview;
    public CyApplicationManager cyApplicationManager;
    public CySwingApplication cytoscapeDesktopService;
    public CyActivator cyactivator;
    public TaskManager taskManager;
    public List<CyNode> GiantComponent;
    public List<CyNode> NodestoConnect;

    //  public Vector<Centrality> VectorResults = new Vector();
	public LoadNetworkURLTaskFactory networkURLLoader;
	public OpenSessionTaskFactory loadSession;
        public RowsSetListener myrowssetlistener;

    /**
     * Creates new form PescaStartMenujLabel1
     * 
     */
    public PescaStartMenu(CyApplicationManager cyApplicationManager, CySwingApplication cytoscapeDesktopService, CyActivator cyactivator, PescaCore pescacore) 
    {
        initComponents();
        //currentnetwork = cyApplicationManager.getCurrentNetwork();
        
        //DefaultComboBoxModel model = new DefaultComboBoxModel();
        final UrlRead reader=new UrlRead(networkURLLoader,taskManager);
        //model=reader.getURLS();      
//        CyApplicationManager t=cyactivator.getcyApplicationManager();
        urlReadDropdown.setModel(reader.getURLS());
        urlReadDropdown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
            	JComboBox combo = (JComboBox) evt.getSource();
                String selectedURL = (String) combo.getSelectedItem();
                System.out.println(selectedURL);
                loadNetwork(selectedURL);
                
                
            }
        });
        buttonGroup1.add(spTreeRadioButton);
//        buttonGroup1.add(spRadioButton);
//        buttonGroup1.add(spAllNodesButton);
        buttonGroup1.add(spClusterRadioButton);
        buttonGroup1.add(spIsolatednodesRadioButton);

        lastworkednetwork = null;
        lastworkedview = null;
       
        this.cyactivator = cyactivator;
        this.cyApplicationManager = cyactivator.getcyApplicationManager();
        this.taskManager = cyactivator.getTaskManager();
        this.networkURLLoader = cyactivator.getNetworkURLLoader();
        this.loadSession=cyactivator.getOpenSessionTaskFactory();;
        this.cytoscapeDesktopService = cytoscapeDesktopService;
        this.pescacore = pescacore;
         Pescaalg = new PescaAlgorithm(pescacore);
      
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     * 
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel5 = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        spTreeHelpButton = new javax.swing.JButton();
        spTreeRadioButton = new javax.swing.JRadioButton();
        spClusterRadioButton = new javax.swing.JRadioButton();
        spClusterHelpButton = new javax.swing.JButton();
        spIsolatednodesRadioButton = new javax.swing.JRadioButton();
        spIsolatednodesHelpButton = new javax.swing.JButton();
        directedButton = new javax.swing.JCheckBox();
        weightedButton = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        StartButton = new javax.swing.JButton();
        StopButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jProgressBar1 = new javax.swing.JProgressBar();
        ExitButton = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        urlReadDropdown = new javax.swing.JComboBox();

        setBorder(javax.swing.BorderFactory.createEtchedBorder());
        setPreferredSize(new java.awt.Dimension(360, 480));

        jScrollPane1.setToolTipText("");
        jScrollPane1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane1.setPreferredSize(new java.awt.Dimension(310, 563));

        jPanel5.setBorder(new javax.swing.border.MatteBorder(null));
        jPanel5.setPreferredSize(new java.awt.Dimension(360, 560));

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Shortest path options"));
        jPanel1.setFont(new java.awt.Font("Dialog", 0, 14)); // NOI18N
        jPanel1.setPreferredSize(new java.awt.Dimension(350, 341));

        spTreeHelpButton.setText("?");
        spTreeHelpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spTreeHelpButtonActionPerformed(evt);
            }
        });

        spTreeRadioButton.setText("Multi Shortest Paths Tree");
        spTreeRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spTreeRadioButtonActionPerformed(evt);
            }
        });

        spClusterRadioButton.setText("Multi Shortest Paths (S-P Cluster)");
        spClusterRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spClusterRadioButtonActionPerformed(evt);
            }
        });

        spClusterHelpButton.setText("?");
        spClusterHelpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spClusterHelpButtonActionPerformed(evt);
            }
        });

        spIsolatednodesRadioButton.setText("Connect isolated nodes");
        spIsolatednodesRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spIsolatednodesRadioButtonActionPerformed(evt);
            }
        });

        spIsolatednodesHelpButton.setText("?");
        spIsolatednodesHelpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                spIsolatednodesHelpButtonActionPerformed(evt);
            }
        });

        directedButton.setText("Directed network");
        directedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                directedButtonActionPerformed(evt);
            }
        });

        weightedButton.setText("Weighted network");

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(spTreeRadioButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(spTreeHelpButton))
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(spClusterRadioButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 46, Short.MAX_VALUE)
                        .add(spClusterHelpButton))
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(spIsolatednodesRadioButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(spIsolatednodesHelpButton))
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(weightedButton)
                            .add(directedButton))
                        .add(0, 0, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(27, 27, 27)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(spTreeRadioButton)
                    .add(spTreeHelpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 18, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(13, 13, 13)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(spClusterRadioButton)
                    .add(spClusterHelpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 18, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(18, 18, 18)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(spIsolatednodesRadioButton)
                    .add(spIsolatednodesHelpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 18, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(18, 18, 18)
                .add(directedButton)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(weightedButton)
                .addContainerGap(50, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel2.setPreferredSize(new java.awt.Dimension(290, 129));

        StartButton.setText("Start");
        StartButton.setEnabled(false);
        StartButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StartButtonActionPerformed(evt);
            }
        });

        StopButton.setText("Stop");
        StopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StopButtonActionPerformed(evt);
            }
        });

        jLabel1.setText("Click Start to calculate");

        jSeparator1.setForeground(java.awt.Color.gray);

        ExitButton.setText("Exit");
        ExitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExitButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel2Layout.createSequentialGroup()
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(jPanel2Layout.createSequentialGroup()
                        .add(12, 12, 12)
                        .add(jSeparator1))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .add(StartButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(StopButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(ExitButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jLabel1))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .add(jProgressBar1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .add(jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 14, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jProgressBar1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jSeparator1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(12, 12, 12)
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(ExitButton)
                    .add(StopButton)
                    .add(StartButton))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel2.setFont(new java.awt.Font("Dialog", 1, 16)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(255, 0, 51));
        jLabel2.setText("Pesca Menu2");

        urlReadDropdown.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        org.jdesktop.layout.GroupLayout jPanel5Layout = new org.jdesktop.layout.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel5Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel5Layout.createSequentialGroup()
                        .add(0, 0, Short.MAX_VALUE)
                        .add(jLabel2)
                        .add(320, 320, 320))
                    .add(jPanel5Layout.createSequentialGroup()
                        .add(jPanel5Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jPanel5Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                                .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 326, Short.MAX_VALUE)
                                .add(jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 326, Short.MAX_VALUE))
                            .add(urlReadDropdown, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 262, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .add(0, 0, Short.MAX_VALUE))))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .add(jLabel2)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(urlReadDropdown, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 280, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 121, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(84, Short.MAX_VALUE))
        );

        jPanel1.getAccessibleContext().setAccessibleName("Shortest paths options");

        jScrollPane1.setViewportView(jPanel5);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 332, Short.MAX_VALUE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 497, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    //  }

    
    
    
   
    
    private void spTreeHelpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spTreeHelpButtonActionPerformed
        // TODO add your handling code here:
      PescaHelp help = new PescaHelp();
        help.setText("MULTISHORTEST PATHS TREE\n "
                
                + "The shortest path tree is the collection of all shortest paths linking one specific node to all other nodes in a network. Given a connected, undirected graph G, a shortest-path tree rooted at vertex v is a spanning tree T of G, such that the path distance from root v to any other vertex u in T is the shortest path distance from v to u in G. Like minimum spanning trees, shortest-path trees in general are not unique. In graphs for which all edges weights equal one, shortest path trees coincide with breadth-first search trees. In graphs that have negative cycles, the set of shortest simple paths from v to all other vertices do not necessarily form a tree. If the tree is calculated for a directed graph (directed edges) it is possible that a path between the selected node and some other nodes in the network is not computed. For instance, A->B and A<-B represent the same interaction but with different directions; so if A is selected and a directed computation is run then a shortest path will be found only for A->B."
                /*+ "The shortest path is the minimal path connecting two nodes.  More specifically, in graph theory the shortest path problem consists in finding a path between two vertices (or nodes) in a graph such that the sum of its constituent edges is minimized. \n" +
"\n" +
"If more than two nodes are selected, then the shortest paths connecting each couple of the selected nodes are computed.\n" +
"\n" +
"The edges can be un-weighted or weighted depending of the variability of edge length: if un-weighted the length of all edges is assumed to be constant within the graph; if weighted the edge length is variable and is associated to a number expressing any kind of functional meaning related to the physical nature of the network. If one represents a nondeterministic abstract machine as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to find an optimal sequence of choices to reach a certain state, or to establish lower bounds on the time needed to reach a given state. For example, if vertices represent the states of a puzzle like a Rubik's Cube and each directed edge corresponds to a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves. Shortest path algorithms are also applied to automatically find directions between physical locations, such as driving directions on web mapping websites like MapQuest or Google Maps. In biological networks, such as a protein-protein interaction network, the shortest path defines the minimal number of protein interactions mediating the functional link between two proteins, where a direct physical interaction between two proteins has the lowest shortest path (= 1).  Since many (shortest) paths can connect two nodes, the implemented algorithm computes all possible shortest paths between two selected nodes. Shortest path can be calculated either for non-directed or directed networks, depending if edge direction is undefined (A-B) or is defined (A->B). Of course the two cases will likely generate different results and assume different functional meaning. For instance, in a signal transduction network, edge directionality provides information about the informational flow in the network and, thus, the shortest path will represent the minimal thermodynamics cost generating that flow. "
                               + "In graph theory, the shortest path problem is the problem of finding a path between two vertices " +
        		"(or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. In an unweighted graph the weights" +
        		" are assumed to be constant." +"Shortest path algorithms are applied to automatically find directions between physical locations," +
        				" such as driving directions on web mapping websites like Mapquest or Google Maps. If one represents a nondeterministic abstract " +
        				"machine as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to " +
        				"find an optimal sequence of choices to reach a certain goal state, or to establish lower bounds on the time needed to reach a" +
        				" given state. For example, if vertices represent the states of a puzzle like a Rubik's Cube and each directed edge corresponds to " +
        				"a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves."*/
);
        help.setVisible(true);
    }//GEN-LAST:event_spTreeHelpButtonActionPerformed


private void spClusterHelpButtonActionPerformed(java.awt.event.ActionEvent evt) {                                                    
    // TODO add your handling code here:
     PescaHelp help = new PescaHelp();
        help.setText("MULTISHORTEST PATHS \n "
                + "The shortest path is the minimal path connecting two nodes.  More specifically, in graph theory the shortest path problem consists in finding a path between two vertices (or nodes) in a graph such that the sum of its constituent edges is minimized. \n" +
"\n" +
"If more than two nodes are selected, then the shortest paths connecting each couple of the selected nodes are computed.\n" +
"\n" +
"The edges can be un-weighted or weighted depending of the variability of edge length: if un-weighted the length of all edges is assumed to be constant within the graph; if weighted the edge length is variable and is associated to a number expressing any kind of functional meaning related to the physical nature of the network. If one represents a nondeterministic abstract machine as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to find an optimal sequence of choices to reach a certain state, or to establish lower bounds on the time needed to reach a given state. For example, if vertices represent the states of a puzzle like a Rubik's Cube and each directed edge corresponds to a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves. Shortest path algorithms are also applied to automatically find directions between physical locations, such as driving directions on web mapping websites like MapQuest or Google Maps. In biological networks, such as a protein-protein interaction network, the shortest path defines the minimal number of protein interactions mediating the functional link between two proteins, where a direct physical interaction between two proteins has the lowest shortest path (= 1).  Since many (shortest) paths can connect two nodes, the implemented algorithm computes all possible shortest paths between two selected nodes. Shortest path can be calculated either for non-directed or directed networks, depending if edge direction is undefined (A-B) or is defined (A->B). Of course the two cases will likely generate different results and assume different functional meaning. For instance, in a signal transduction network, edge directionality provides information about the informational flow in the network and, thus, the shortest path will represent the minimal thermodynamics cost generating that flow. "
                               /*+ "In graph theory, the shortest path problem is the problem of finding a path between two vertices " +
        		"(or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. In an unweighted graph the weights" +
        		" are assumed to be constant." +"Shortest path algorithms are applied to automatically find directions between physical locations," +
        				" such as driving directions on web mapping websites like Mapquest or Google Maps. If one represents a nondeterministic abstract " +
        				"machine as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to " +
        				"find an optimal sequence of choices to reach a certain goal state, or to establish lower bounds on the time needed to reach a" +
        				" given state. For example, if vertices represent the states of a puzzle like a Rubik's Cube and each directed edge corresponds to " +
        				"a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves."*/
);
        help.setVisible(true);
    }     
    
    /*
	 PescaHelp help = new PescaHelp();
     help.setText("SP CLUSTER\nGiven an undirected/ directed graph G = (V,E), where each edge has a nonnegative cost C, for all pairs of selected vertices (v,w), " +
     		"SP clusters algorithm finds the lowest cost path from v to w. SP clusters is a modification between single-source-shortest-path problem and All source " +
     		"shortest path, where only a selected group of vertices, path is found. We use Dijkstra's algorithm, varying the source node among all the nodes in the " +
     		"group selected. Here we recover the path itself, and not just the cost of the path.");
     help.setVisible(true);
} */                                                  

  
    private void spAllNodesHelpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spClusterHelpButtonActionPerformed
        // TODO add your handling code here:
    	 PescaHelp help = new PescaHelp();
         help.setText("ALL NODES\n"
                 + "The algorithm computes all shortest paths between all nodes in a network. If the paths are calculated for a directed graph (directed edges) it is possible that a path between some nodes is not computed. Given an undirected/ directed graph G = (V,E), where each edge has a nonnegative cost C, for all pairs of vertices (v,w), all nodes shortest path algorithm finds the lowest cost path from v to w. All nodes shortest path is a generalization of the single-source-shortest-path problem. We use Dijkstra's algorithm, varying the source node among all the nodes in the graph. Here we recover the path itself, and not just the cost of the path. "
                /* + "Given an undirected/ directed graph G = (V,E), where each edge has a nonnegative cost C, for all pairs of vertices " +
         		"(v,w), all nodes shortest path algorithm finds the lowest cost path from v to w. All nodes shortest path is a generalization of the" +
         		" single-source-shortest-path problem. We use Dijkstra's algorithm, varying the source node among all the nodes in the graph. Here we" +
         		" recover the path itself, and not just the cost of the path."*/
                 );
         help.setVisible(true);
    }//GEN-LAST:event_spClusterHelpButtonActionPerformed

    private void spIsolatednodesHelpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spIsolatednodesHelpButtonActionPerformed
        // TODO add your handling code here:
    	 PescaHelp help = new PescaHelp();
         help.setText("CONNECT ISOLATED NODES\n" +
                 
         		"The algorithm defines an assisted procedure to connect isolated nodes to a sub-graph in a connected giant component. By selecting a sub network and a connecting node not part of the sub network, we can get the shortest path from that node to the selected sub network. Follow the wizard to activate the procedure."
         /*        + "By selecting a subnetwork and a connecting node not part of the subnetwork, we can get the shortest path from that " +
         		"node to the subnetwork selected. "*/);
         help.setVisible(true);
    }//GEN-LAST:event_spIsolatednodesHelpButtonActionPerformed



    private void ExitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExitButtonActionPerformed
        // call stop

        // CyNetworkView view = Cytoscape.getCurrentNetworkView();

       Object[] options = {"YES", "NO"};
        int answer = JOptionPane.showOptionDialog(null, "Are you sure you want to exit?", "Pesca",
                JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE,
                null, options, options[0]);

        if (answer == 0) {
            if (calculating) {
                if (ThrEng.isAlive()) {
                    ThrEng.endprogram();
                }
                stopcalculus();
            }

            closePesca();
          

        }
    }//GEN-LAST:event_ExitButtonActionPerformed

    private void StopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StopButtonActionPerformed
        // TODO add your handling code here:
        if (calculating) {
            if (ThrEng.isAlive()) {
                ThrEng.endprogram();
            }
            stopcalculus();
        }
    }//GEN-LAST:event_StopButtonActionPerformed

    private void StartButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StartButtonActionPerformed
       System.out.println("No network");
       currentnetworkview = cyApplicationManager.getCurrentNetworkView();
        if (currentnetworkview == null               ) {
            System.out.println("No network1");
            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                    "No network selected!", "Pesca", JOptionPane.WARNING_MESSAGE);
        return;
        }
        else
       currentnetworkview = cyApplicationManager.getCurrentNetworkView();
       CyNetwork currentnetwork = currentnetworkview.getModel();
       String currentnetworkname = currentnetwork.getRow(currentnetwork).get("name", String.class);
   //    System.out.println("la network selected e' " + currentnetwork.getTable(CyNode.class, currentnetworkname).toString());
        System.out.println("la network e' " + currentnetworkname);
        if (currentnetwork.getNodeList().isEmpty()) {
            System.out.println("No network2");
            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                    "No network selected!", "Pesca", JOptionPane.WARNING_MESSAGE);
        } else {
            
            CyNode node = (CyNode)currentnetworkview.getModel().getNodeList().get(1);
            
       //     System.out.println("yes network" + node.toString() + " hhh" + currentnetworkview.getModel().getNodeList().toString());
//System.out.println("yes network" + currentnetwork.getRow(node).get("name",String.class));
List<CyNode> nodes = CyTableUtil.getNodesInState(currentnetwork,"selected",true);
//System.out.println("yes network" + nodes.toString()); 

            int answer = 0;
            if (iscurrentnetworkchanged()) {
                System.out.println("network changed");
                Object[] options = {"Start computation", "Abort computation"};
                answer =      
                        JOptionPane.showOptionDialog(
                        this.cytoscapeDesktopService.getJFrame()
                    ,
                        "Attention! You have changed the current network. ",
                        //+
                        // "Starting a new computation you will\n" +
                        // "loose all the previous network attributes. " +
                        // "Save them before proceeding.", 
                        "Pesca",
                        JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, options, options[0]);

            }
            else {
                System.out.println("network not changed");
            }

            if (answer == 0) {
                changelastworkednetwork(currentnetwork, currentnetworkview);
                inizio = System.currentTimeMillis();
                System.out.println("start time =" + inizio);
                this.setEnabled(false);
                // verify Checkbox
                CheckedCentralities[0] = spTreeRadioButton.isSelected();
               // CheckedCentralities[1] = spRadioButton.isSelected();
                CheckedCentralities[2] = spClusterRadioButton.isSelected();
                CheckedCentralities[3] = spIsolatednodesRadioButton.isSelected();
//                CheckedCentralities[4] = spAllNodesButton.isSelected();
                directed = directedButton.isSelected();
                weighted=  weightedButton.isSelected();
                int secondanswer = 0;
            
                System.out.println(weighted);
                Pescaalg.setChecked(CheckedCentralities, directed, weighted);

                if (secondanswer == 0) {
                    CyNetworkView view = currentnetworkview;//Cytoscape.getCurrentNetworkView();
                    List<CyNode> lista = CyTableUtil.getNodesInState(currentnetwork,"selected",true);
                            //view.getSelectedNodes();
                    if (CheckedCentralities[0]) {
                       
                       if(lista.size() == 1)
                        {
                            calculatingresult();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();
                        

                        } else {
                            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                                    //view.getComponent(),
                                    "Please select one node to start computation");
                        }

                    }
                   /* if (CheckedCentralities[1]) {
                        if (lista.size() == 2) {
                            calculatingresult();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();
                        } else {
                            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                                  //  view.getComponent(),
                                    "Please select source and target nodes to start computation");
                        }

                    }*/

                    if (CheckedCentralities[2]) {
                        if (lista.size() >= 2) {
                            calculatingresult();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();
                        } else {
                            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                                    //view.getComponent(),
                                    "Please select two or more nodes");
                        }
                    }

                    if (CheckedCentralities[3]) {
                        
                        
                          System.out.println("fatto1");
                          
                       
      
                          
                          
                          
                          
                                 PescaIsolatedWindows currentwindows = new PescaIsolatedWindows(currentnetwork, this);
                                 
                            //       cyactivator.getcyServiceRegistrar().registerService(currentwindows, CytoPanelComponent.class, new Properties());
                              //   CytoPanel cytopanelwest = cytoscapeDesktopService.getCytoPanel(CytoPanelName.WEST);
                                //  int index = cytopanelwest.indexOfComponent(currentwindows);
                                  // cytopanelwest.setSelectedIndex(index);
                                  
                                 
                                 currentwindows.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                            
                                 currentwindows.setVisible(true);
                                 System.out.println("fatto2");
                        
                        
                    	/* if (lista.size() == 1) {
                             
                        	 JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                                     //view.getComponent(),
                                     "Select subnetwork and press start");
                                
                                 
                        	 Pescaalg.source=lista.get(0);
                        }
                                 else if (lista.size() > 1 && Pescaalg.source!=null) {*/
                                 
                           /* calculatingresult();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();*/
                       /* } else {
                            JOptionPane.showMessageDialog(this.cytoscapeDesktopService.getJFrame(),
                                   // view.getComponent(),
                                    "Please select the isolated node");
                            
                            
                            
                        }*/
                    }
                    
                    if (CheckedCentralities[4]) {
                       
                            calculatingresult();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();                       
                    }

                    
                    this.setEnabled(true);
                }
            }
        }
    }//GEN-LAST:event_StartButtonActionPerformed

private void spTreeRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spTreeRadioButtonActionPerformed
    verifyselection();// TODO add your handling code here:
}//GEN-LAST:event_spTreeRadioButtonActionPerformed

private void spRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {                                              
    verifyselection(); //TODO add your handling code here:
}                                             

private void spClusterRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spClusterRadioButtonActionPerformed
    // TODO add your handling code here:
    verifyselection();
}//GEN-LAST:event_spClusterRadioButtonActionPerformed

private void spIsolatednodesRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_spIsolatednodesRadioButtonActionPerformed
    // TODO add your handling code here:
     verifyselection();
}//GEN-LAST:event_spIsolatednodesRadioButtonActionPerformed

    private void directedButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_directedButtonActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_directedButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ExitButton;
    private javax.swing.JButton StartButton;
    private javax.swing.JButton StopButton;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JCheckBox directedButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JButton spClusterHelpButton;
    private javax.swing.JRadioButton spClusterRadioButton;
    private javax.swing.JButton spIsolatednodesHelpButton;
    private javax.swing.JRadioButton spIsolatednodesRadioButton;
    private javax.swing.JButton spTreeHelpButton;
    private javax.swing.JRadioButton spTreeRadioButton;
    private javax.swing.JComboBox urlReadDropdown;
    private javax.swing.JCheckBox weightedButton;
    // End of variables declaration//GEN-END:variables

    public void endcalculus(int totalnodecount) {

        this.jProgressBar1.setIndeterminate(false);
        jLabel1.setText("Finished: " + totalnodecount + " nodes worked");
        StartButton.setEnabled(true);
        calculating = false;
        StartButton.setEnabled(true);
        fine = System.currentTimeMillis();
        System.out.println("end time =" + fine + ", execution time (millis) = " + (fine - inizio));

    }

    public void stopcalculus() {
        this.jProgressBar1.setIndeterminate(false);
        jLabel1.setText("Interrupted by user, click start to repeat");
        //StartButton.setEnabled(true);
        calculating = false;
        StartButton.setEnabled(true);
    }

    public void calculatingresult() {

        calculating = true;
        jProgressBar1.setIndeterminate(true);
        jProgressBar1.setVisible(true);
        jLabel1.setText("Calculating...");
        StartButton.setEnabled(false);

    }

    public void updatenodecounting(int nodeworked, int totalnodecount) {

        jLabel1.setText("Working: node " + nodeworked + " of " + totalnodecount);


    }

    public void closePesca() {

       pescacore.closePescavisualizer();
       pescacore.closePescaStartMenu();
      

    }
   
	
	private class DummyTask extends AbstractTask{

		@Override
		public void run(TaskMonitor taskMonitor) throws Exception {
			//DO nothing it is a dummy tas just to initiate the iterator
		}
		
	}
	
	public static void saveFileFromUrlWithJavaIO(String fileName, String fileUrl)	throws MalformedURLException, IOException 
	{
		File f=new File(fileName);
		if(!f.exists())
		{

			BufferedInputStream in = null;
		
			FileOutputStream fout = null;
		
			try {
		
			in = new BufferedInputStream(new URL(fileUrl).openStream());
		
			fout = new FileOutputStream(fileName);
		
			byte data[] = new byte[1024];
		
			int count;
			
				while ((count = in.read(data, 0, 1024)) != -1) {
			
				fout.write(data, 0, count);
				
				}
		
			} 
			finally {
			
			if (in != null)
		
			in.close();
		
			if (fout != null)
		
			fout.close();
		
			}
		}
				
	}

	
	public void loadNetwork (String u){
	
		ArrayList<TaskIterator> taskIteratorList = new ArrayList<TaskIterator>();
		URL r;
		if(u.endsWith("sif"))
		{
			System.out.println("Helloooooo");
			try {
				
				System.out.print(u);
				r = new URL("http://dp.univr.it/~laudanna/LCTST/downloads/files/"+u);
				
				
				taskIteratorList.add( networkURLLoader.loadCyNetworks(r) );
				
			
			
				
				
				
			} catch (MalformedURLException em) {
				// TODO Auto-generated catch block
				em.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}	
		else
		{
		System.out.print("here");
			try {
				System.out.print("here");
				saveFileFromUrlWithJavaIO(System.getProperty("java.io.tmpdir")+"/"+u, "http://dp.univr.it/~laudanna/LCTST/downloads/files/"+u);
			} catch (MalformedURLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.print("here");
			final File targetFile = new File(System.getProperty("java.io.tmpdir")+"/"+u);
			taskIteratorList.add(loadSession.createTaskIterator(targetFile));
		}
		
	
	 
	  
		Task initTask = new DummyTask();
		TaskIterator taskIterator = new TaskIterator(taskIteratorList.size(), initTask);
		for (int i= taskIteratorList.size()-1; i>= 0 ; i--){
			TaskIterator ti = taskIteratorList.get(i);
			taskIterator.insertTasksAfter(initTask, ti);
		}
		
		taskManager.execute(taskIterator);
		
		// TODO Auto-generated method stub
		
	}

/*    public void removeattributes() {
        CyAttributes currentNodeAttributes = Cytoscape.getNodeAttributes();
        CyAttributes currentNetworkAttributes = Cytoscape.getNetworkAttributes();
        String currentnetworkid = Cytoscape.getCurrentNetwork().getIdentifier();

        if (CheckedCentralities[0] || LoadedCentralities[0]) {

            currentNetworkAttributes.deleteAttribute("Pesca Diameter");
        }



        if (CheckedCentralities[1] || LoadedCentralities[1]) {

            currentNetworkAttributes.deleteAttribute("Pesca Average Distance");
        }


        if (CheckedCentralities[2] || LoadedCentralities[2]) {

            currentNodeAttributes.deleteAttribute("Pesca Node degree");

            currentNetworkAttributes.deleteAttribute("Pesca degree Max value");
            currentNetworkAttributes.deleteAttribute("Pesca degree min value");
            currentNetworkAttributes.deleteAttribute("Pesca degree mean value");


        }
      
        for (int i = 0; i < numberofcentralities; i++) {
            LoadedCentralities[i] = false;



        }

    }

    public void hideattributes() {

        CyAttributes currentNodeAttributes = Cytoscape.getNodeAttributes();
        CyAttributes currentNetworkAttributes = Cytoscape.getNetworkAttributes();

        //if (CheckedCentralities[0]) {

        //    currentNetworkAttributes.setUserVisible("Pesca Diameter",false);
        System.out.println("hiding diameter");
        //}

        CytoscapeDesktop desktop = Cytoscape.getDesktop();
        CytoPanel cytoPanelsouth = desktop.getCytoPanel(SwingConstants.SOUTH);
        cytoPanelsouth.setState(CytoPanelState.HIDE);
        cytoPanelsouth.setState(CytoPanelState.DOCK);
        System.out.println("hiding attributes");
     
    }

    public void enableStart() {
        StartButton.setEnabled(true);
    }*/

    public void changelastworkednetwork(CyNetwork newnetwork, CyNetworkView newview) {
        lastworkednetwork = newnetwork;
        lastworkedview = newview;
    }
/*
    public CyNetworkView getlastworkedview() {
        return lastworkedview;
    }*/

    public boolean iscurrentnetworkchanged() {

     /*   if (lastworkedview == null) {
            return false;
        } else if (lastworkedview.getNodeViewCount() == 0) {
            return false;
        } else {
            return !lastworkedview.getTitle().equals(Cytoscape.getCurrentNetworkView().getTitle());
        }*/
        // da eliminare quando tolgo i commenti sopra
        return false;
    }
/*
    public String verifyloadedattributes(boolean[] selectedCentralities) {

        boolean[] loadedCentralities = new boolean[numberofcentralities];
        int loadedcentralities = 0;
        String stringcentralities = "";
        CyAttributes currentNetworkAttributes = Cytoscape.getNetworkAttributes();



        loadedCentralities[0] = currentNetworkAttributes.hasAttribute(Cytoscape.getCurrentNetwork().getIdentifier(), "Pesca Diameter");
        loadedCentralities[1] = currentNetworkAttributes.hasAttribute(Cytoscape.getCurrentNetwork().getIdentifier(), "Pesca Average Distance");
       

        for (int i = 0; i < numberofcentralities; i++) {
            if (selectedCentralities[i] & loadedCentralities[i]) {
                loadedcentralities++;
                switch (i) {
                    case 0:
                        stringcentralities = stringcentralities + "Diameter, ";
                        break;
                    case 1:

                        stringcentralities = stringcentralities + "Average Distance, ";
                        break;
                    case 2:
                        stringcentralities = stringcentralities + "Degree, ";
                        break;
                    case 3:
                        stringcentralities = stringcentralities + "Eccentricity, ";
                        break;
                    case 4:
                        stringcentralities = stringcentralities + "Radiality, ";
                        break;
                    case 5:
                        stringcentralities = stringcentralities + "Closeness, ";
                        break;
                    case 6:
                        stringcentralities = stringcentralities + "Stress, ";
                        break;
                    case 7:
                        stringcentralities = stringcentralities + "Betweenness, ";
                        break;
                    case 8:
                        stringcentralities = stringcentralities + "Centroid value, ";
                        break;
                }
            }
        }

        if (loadedcentralities == 1) {
            stringcentralities = stringcentralities.substring(0, stringcentralities.length() - 2) + " is ";
        } else if (loadedcentralities > 1) {
            stringcentralities = stringcentralities.substring(0, stringcentralities.length() - 2);
            stringcentralities = stringcentralities.substring(0, stringcentralities.lastIndexOf(',')) + " and" + stringcentralities.substring(stringcentralities.lastIndexOf(',') + 1) + " are ";
        } else {
            stringcentralities = null;
        }
        return stringcentralities;
    }

    public boolean isalreadyloaded(String centralitiestring) {

        CyAttributes currentNodeAttributes = Cytoscape.getNodeAttributes();
        String[] attributesarray = currentNodeAttributes.getAttributeNames();
        boolean result = false;
        for (int i = 0; i < attributesarray.length; i++) {
            if (centralitiestring.equals(attributesarray[i])) {
                result = true;
                return result;
            }
        }
        return result;
    }*/

    public void verifyselection() {
        if (spTreeRadioButton.isSelected() /*|| spRadioButton.isSelected()*/ 
                || spClusterRadioButton.isSelected() || spIsolatednodesRadioButton.isSelected() /*|| spAllNodesButton.isSelected()*/) {

       


            StartButton.setEnabled(true);
        } else {
            StartButton.setEnabled(false);
        }
    }
    
    public Component getComponent() {
		return this;
	}
    
    public void startcomputation() {
        calculatingresult();
        currentnetwork = cyApplicationManager.getCurrentNetwork();
                            ThrEng = new PescaThreadEngine(Pescaalg, currentnetwork, currentnetworkview);
                            ThrEng.setCaller(this);
                            ThrEng.start();
    }


	public CytoPanelName getCytoPanelName() {
		return CytoPanelName.WEST;
	}


	public String getTitle() {
		return "Pesca";
	}


	public Icon getIcon() {
		return null;
	}
}
